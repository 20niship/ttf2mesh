Здравствуйте, Друзья!
Когда-то давно столкнулся с известной проблемой трёхмерной графики - отсутствие простых кроссплатформенных решений в вопросе вывода текста. Известные реализации позволяют выбранный шрифт использовать в виде текстуры. Публикуемая библиотека ttf2mesh реализует другой способ - она преобразует векторные символы TrueType шрифта в сеточные объекты. Это позволяет выводить текст в виде набора треугольников. Такой подход имеет как важные преимущества, так и недостатки.
Сложность описываемой далее задачи и созерцание великолепных форм шрифтового дизайна доставили массу удовольствия при разработке. Надеюсь, и Вам понравится.<br>
<img src="https://habrastorage.org/webt/ge/o4/q0/geo4q0i6y-ue6hqpbw7gcflnww8.gif" /><br>

<h3>Погружение в проблему</h3>
<p>На сайте stackoverflow можно встретить <a href="https://stackoverflow.com/questions/8847899/how-to-draw-text-using-only-opengl-methods">вопрос</a> "How to draw text using only OpenGL methods?". Развёрнутый ответ к нему, начинается с фразы "Why it is hard". Дам краткий перевод этого ответа, поскольку лучше - едва ли получится описать проблему.</p>
<p>Распространённые шрифты (такие как TrueType или OpenType) имеют векторный формат представления символов: их очертание задаётся набором кривых Безье.<br>
<img src="https://habrastorage.org/webt/qx/ro/xy/qxroxy7jked2j4ivzpcfknwgrgw.gif" /><br>
Растеризация данных в таком формате - достаточно специфическая задача и выходит за рамки OpenGL, который привык оперировать с примитивами меньшей сложности (точки, прямые, треугольники).
Поэтому, простым способом признаётся растеризация шрифта на CPU, а затем - передача символов OpenGL-у в виде текстуры. Вместо множества текстур малого размера принято использовать одну текстуру, содержащую всё множество нужных символов. Такой подход иногда называют <a href="https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D0%BA%D1%81%D1%82%D1%83%D1%80%D0%BD%D1%8B%D0%B9_%D0%B0%D1%82%D0%BB%D0%B0%D1%81">текстурным атласом</a>:
<br><img src="https://habrastorage.org/webt/qf/vf/jt/qfvfjts8pohy8hddpvwfhgs0yq4.png" /><br>
Подготовить такой атлас непросто учитывая попытку наиболее плотным образом разместить символьные глифы в родительском прямоугольнике. Также указывается, что подобная техника используется в web-дизайне (CSS-sprites).</p>
<p>На конференции <a href="https://youtu.be/LZis03DXWjE?t=886">FOSDEM 2014</a>, отмечает автор ответа, рассматривались и другие существующие техники:
<ol>
<li>Тесселяция: преобразуем символы шрифта в набор треугольников. Последние GPU хорошо умеет выводить. Недостатки: формируется много треугольников; процесс имеет сложность O(N log N)</li>
<li>Вычислять кривые на шейдерах. Недостатки: сложно, см. <a href="https://stackoverflow.com/questions/15519142/resolution-independent-cubic-bezier-drawing-on-gpu-blinn-loop">Resolution independent cubic bezier drawing on GPU (Blinn/Loop)</a></li>
<li>Прямая аппаратная реализация вроде OpenVG. Недостатки: API не получил единой, широко распространённой реализации (см. <a href="https://stackoverflow.com/questions/20186811/opengl-openvg-draw-text">OpenGL, OpenVG. Draw text</a> и <a href="https://stackoverflow.com/questions/401422/openvg-implementation">OpenVG implementation</a>)</li>
</ol></p>
<p>Автор ответа рассказывает, что отображение 3d-текста в перспективной проекции тоже является объектом исследований на момент Марта 2016 года. Самой популярной техникой в этой области является т.н. "Distance fields" (техника работы с растром, см. на <a href="https://habr.com/ru/post/245729/">хабре</a>). Далее рассказывается об известных реализациях.</p>
<p><u>Решения на базе FreeType</u>
Библиотека FreeType для растеризации шрифтов имеет открытый искодный код и большую популярность. По этой причине также получила популярность библиотека <a href="https://github.com/rougier/freetype-gl">FTGL</a>, которая предоставляет удобный API, позволяет формировать текстурные атласы и использует "Distance fields" из коробки.
Другая известная библиотека - libgdx.</p>
<p><u>Решения на базе других растеризаторов</u>
<a href="https://github.com/nothings/stb/blob/master/stb_truetype.h">github.com/nothings/stb/blob/master/stb_truetype.h</a>
<a href="http://www.angelcode.com/products/bmfont/">www.angelcode.com/products/bmfont</a>
</p>
<p>Далее автор ответа приводит разные библиотеки, позволяющие вывести текст с использованием растеризированного шрифта. Отличия реализаций заключаются в форматах текстур (DDS, PNG) и привлекаемых растеризаторах. Детально останавливаться на этом не станем - советую изучить оригинальный топик.</p>
<p>Рассмотрим указанные на FOSDEM 2014 недостатки тесселяции.</p>
<p><u>1. Формируется много треугольников</u>
Сразу напрашивается вопрос: а много - это сколько? Следующее изображение имеет в полном тексте с хорошим качеством 6000 треугольников (проверено на шрифте Ubuntu без засечек):
<br><img src="https://habrastorage.org/webt/ln/a0/es/lna0eslnfqzmyjfi-gqfeo5dnza.jpeg" /><br>
Шрифт с засечками даст в 2.5 раза больше треугольников (Times New Roman с засечками, 15000 треугольников).
Много ли это, учитывая, что современные игры в сцене содержат на порядок больше треугольников (а иногда и на два)? Учитывая потенциал оптимизации (выключение источников, текстур, теста глубины, работа с памятью GPU и прочее), такое количество треугольников на мой взгляд не выглядит критическим.</p>
<p><u>2. Сложность O(N log N)</u>
Данная сложность, без сомнений, взята из анализа алгоритмов <a href="https://ru.wikipedia.org/wiki/%D0%A2%D1%80%D0%B8%D0%B0%D0%BD%D0%B3%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F_%D0%94%D0%B5%D0%BB%D0%BE%D0%BD%D0%B5">триангуляции</a>. Вкратце, триангуляция (далее мы будем использовать этот термин) - это то же что тесселяция при замощении фигуры треугольниками. Множитель log(N) затруднительно считать определяющим. Кроме того, он часто нивелируется алгоритмически. Так, например, в книге А.В. Скворцова "Триангуляция Делоне и её применение" указывается, что не смотря на то что некоторые алгоритмы имеют предельную сложность O(N<sup>2</sup>), их средняя производительность всё же стремится к O(N). Далее будет описан алгоритм линейного заметания, применяемая модификация которого незначительно отличается по сложности от O(N).</p>
<p>С учётом сказанного, сеточные шрифты на практике выглядят привлекательно. Они способны решить сразу несколько проблем, присущих текстурным шрифтам:
<ul>
	<li>Сеточные шрифты масштабируемы</li>
	<li>Не нужно хранить объёмные растры для разных шрифтов и их размеров</li>
	<li>Решается проблема перспективной визуализации</li>
	<li>Множество приложений могут обходиться в принципе без текстур</li>
	<li>Сеточные шрифты применимы в других областях (например, в 3d-печати)</li>
</ul></p>
<p>К недостаткам сеточных шрифтов можно отнести: при выводе на экран обязателен <a href="https://ru.wikipedia.org/wiki/%D0%A1%D0%B3%D0%BB%D0%B0%D0%B6%D0%B8%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5">антиалиасинг</a>; число треугольников на некоторых курсивных шрифтах и шрифтах с засечками может показаться большим для мобильных приложений.</p>
<p>Что же. Взвесив все "за" и "против", приступим к описанию того что получилось.</p>
<h3>Описание библиотеки ttf2mesh</h3>
<p>Дизайн сделан под влиянием концепции "не виляй собакой". Поэтому ttf2mesh - это всего два файла (ttf2mesh.h и ttf2mesh.c) написанных в стандарте C99. Основные и обычно попарно вызываемые функции, это:
<table>
<tr><td>Выделение памяти</td><td>Освобождение памяти</td></tr>
<tr><td>ttf_list_fonts и ttf_list_system_fonts</td><td>ttf_free_list</td></tr>
<tr><td>ttf_load_from_file и ttf_load_from_mem</td><td>ttf_free</td></tr>
<tr><td>ttf_glyph2mesh</td><td>ttf_free_mesh</td></tr>
</table>
Не буду останавливаться на описании API. Оно небольшое, а в ttf2mesh.h присутствуют doxygen-комментарии. Добавлю только что есть ещё функция ttf_export_to_obj, позволяющая экспортировать весь шрифт в файл формата Wavefront .obj. Это будет интересно тем, кто решит попробовать использовать сеточный шрифт. Для этих целей в папке examples репозитория лежит приложение-конвертер под названием ttf2obj.</p>
<p>
Процесс преобразования можно разбить на следующие этапы:
1. Чтение TTF-файла шрифта и всего набора векторных глифов, содержащегося в нём
2. Линеаризация контуров (подготовка ломаных из набора гладких кривых)
3. Исправление контурных ошибок
4. Определение контурной иерархии
5. Триангуляция с ограничениями в несколько этапов
5.1. Выпуклая триангуляция
5.2. Добавление ограничений (вставка структурных отрезков)
5.3. Удаление лишних треугольников
5.4. Оптимизация Делоне
6. Подготовка сетки
Далее опишу каждый этап по отдельности.
</p>
<h4>Чтение TTF-файла</h4>
<p>
Полное описание формата файла есть на сайте Microsoft (<a href="https://docs.microsoft.com/ru-ru/typography/opentype/spec/">OpenType specification</a>). OpenType-шрифт (.otf) - это развитый TrueType-шрифт (.ttf), с той же базовой структурой файла, но имеющий некоторые дополнения. Забегая вперёд, скажу, что библиотека пока что поддерживает только TTF, но в скором времени поддержка будет расширена на такие форматы, как OTF и TTC.
</p>
<p>
В двух словах о формате. При продуманной файловой структуре (деление на таблицы похоже на ELF файлы) TrueType формат отличается одной неприятной особенностью... В попытке уменьшить размер файла разработчики заложили великое многообразие вариантов кодирования одной и той же сущности. Эти варианты переключаются в зависимости от разных бит в разных словах... Возможно, на тот момент авторы посчитали, что полноценная компрессия известными методами будет затратной.
</p>
<p>
Парсер TTF-файлов был успешно протестирован на наборе <a href="https://docs.microsoft.com/en-us/typography/fonts/windows_7_font_list">Windows 7 font list</a> и на наборе шрифтов Ubuntu 18.04.4 LTS (в общей сумме более 500 TTF файлов).
Если тема структуры TrueType шрифтов будет интересна читателю - подготовлю отдельную статью. Пока что продолжим.
</p>
<h4>Линеаризация контуров</h4>
<p>
Гладкая кривая - это прекрасно, но сетку можно построить только если её разбить на отрезки. На следующем рисунке показано как влияет введённый параметр outline quality на визуальное качество изображения.
<br><img src="https://habrastorage.org/webt/-2/pd/x6/-2pdx6a15jrfgfpb0tamf3lw_8s.gif" /><br>
Данный параметр численно определяет на какое количество секторов требуется разбить окружность чтобы та не выглядела ребристой.
Каждый раз при подготовке сетки в ttf2mesh требуется указывать этот параметр. При этом предлагается пользоваться определениями TTF_QUALITY_LOW, TTF_QUALITY_NORMAL и TTF_QUALITY_HIGH. Низкий уровень детализации хорош при выводе в маленьком масштабе. При нормальном уровне дефекты фактически не прослеживаются на разных масштабах.
<br><img src="https://habrastorage.org/webt/lx/cz/d1/lxczd1bnzbixx88grh1abzethsc.png" /><br>
При выводе "Q" на обозначенных уровнях детализации формируется 76, 97 и 175 треугольников.
</p>
<h4>Исправление контурных ошибок</h4>
<p>
Поскольку дизайнеров уже похвалил, пришла пора их поругать. Тем более есть за что - они допускают определённые ошибки при дизайне шрифтов. Эти ошибки заключаются в допущении разного рода контурных дефектов. При растеризации контурные дефекты либо не проявляются, либо видны при значительном увеличении. Ввиду специфики процесса триангуляции эти дефекты могут приводить к неудаче при построении сетки. Обнаруживаются следующие ошибки:
- Дублирующиеся контуры
- Самопересечение контура
- Пересечения разных контуров
Рассмотрим эти случаи.
</p>
<p>
<u>Дублирующиеся контуры</u> наблюдаются в нескольких шрифтах, в частности, на символе U+2592 (▒). Это такая шашечка такси на много квадратиков. Очевидно, что можно нарисовать в редакторе несколько квадратиков, а потом их размножить по Ctrl+V. Ну и ничего если несколько квадратиков спряталось точно друг под другом... Триангуляция такие шутки не прощает: если в граф попадает две вершины с одинаковыми координатами, то задача вырождается.
Кроме дублирующихся контуров встречаются и просто дублирующиеся узловые точки, но они библиотекой исключаются из рассмотрения путём либо удаления (если соседние), либо раздвижения контуров на EPSILON.
</p>
<p>
<u>Самопересечение контура</u> - самый неприятный контурный дефект.
Чаще всего случаются перекруты. Это когда на очень небольшой площади глифа натыкано великое множество опорных точек, в результате чего кривая Безье бьётся в конвульсиях и пересекает саму себя несколько раз. Растеризатор это отрабатывает несколько раз проинвертировав цвет соответствующего пикселя, а поскольку этот пиксель лежит где-то в районе антиалиасинга, наблюдатель дефект не замечает. Чаще всего такое наблюдается рядом с первой точкой контура. Догадываетесь почему?
</p>
<p>
<u>Пересечения разных контуров</u> - ещё один вид дефекта.
Существование этого вида дефекта получается объяснить только существованием лени дизайнера и пособничеством в этом компании Microsoft и Apple. Пример ленивого дизайна приводится ниже. Что же касается последних, Microsoft и Apple допускают пересекающиеся и самопересекающиеся контуры (см. <a href="https://developer.apple.com/fonts/TrueType-Reference-Manual/RM06/Chap6AATIntro.html">Overlapping contours</a>) с оговоркой что нужно делать исправление таких шрифтов прежде чем их выводить на принтеры без соответствующей поддержки.
</p>
<p>
К счастью, подобные дефектные глифы встречаются редко и только в мало известных шрифтах (и почему, спрашивается?). Считать такой дизайн некорректным позволяет простое соображение - дизайнер не задумываясь ограничивает набор алгоритмов, пригодных для растеризации его глифа. Имеется в виду, что использовать <a href="https://en.wikipedia.org/wiki/Even%E2%80%93odd_rule">аглоритм even-odd</a> для растеризации становится невозможно, только более затратный <a href="https://en.wikipedia.org/wiki/Nonzero-rule">nonzero</a>.
</p>
<p>
Не смотря на принятые в библиотеке меры по борьбе с контурными дефектами, вероятность неудачной триангуляции сохраняется и равна 0.1% на наборе шрифтов Windows 7. Из 497931 глифов не получается преобразовать в сетку 680 глифов из следующего набора базовой плоскости UNICODE:
<spoiler title="Список неудач по диапазонам UNICODE">
Basic Latin - 14 errors
Latin-1 Supplement - 9 errors
Latin Extended-A - 2 errors
Greek and Coptic - 2 errors
Thai - 11 errors
Letterlike Symbols - 1 errors
Mathematical Operators - 1 errors
Block Elements - 1 errors
Geometric Shapes - 1 errors
Hiragana - 1 errors
Enclosed CJK Letters and Months - 1 errors
CJK Unified Ideographs Extension A - 74 errors
CJK Unified Ideographs - 555 errors
Private Use Area - 3 errors
CJK Compatibility Ideographs - 4 errors
</spoiler>
Если не брать в расчёт иероглифическое и тайское письмо, то всего 36 неудач из 497931 глифов (меньше 0.01%). В группе "Basic Latin", наблюдаются контурные дефекты следующих шрифтов: IrisUPC, KodchiangUPC, LilyUPC, Footlight MT Light, Kunstler Script, Papyrus, Parchment и Viner Hand ITC. По не странному совпадению большинство ошибок кроется в шрифтах UPC (Unity Progress Company).
</p>
<p>
Не смотря на обозначенные неудачи, прогноз в целом утешительный. Делается расчёт на более устойчивые варианты триангуляции, полная победа выглядит достижимой.
</p>
<h4>Определение контурной иерархии</h4>
<p>
Под иерархией подразумевается взаимоотношения контуров между собой. Символ "B", например, имеет 3 контура: один внешний и два контура-отверстия внутри него. Символ "Ы" имеет два независимых внешних контура и 1 внутренний контур-отверстие. Независимый контур с включенными в него контурами-отверстиями составляет один объект триангуляции. На следующей анимации изображён пример последовательной триангуляции нескольких контурных объектов в составе одного глифа.
<br><img src="https://habrastorage.org/webt/rm/iq/hi/rmiqhijenjscfvpp8wejvkz8zkg.gif" /><br>
</p>
<p>
Такая мера вводится, в частности, для для борьбы с неудачной триангуляцией пересекающихся контуров. На рисунке ниже приводится два варианта дизайна символа U+00A2 - корректный, по моему мнению, и не очень.
<table>
<tr>
<td><img src="https://habrastorage.org/webt/ng/t9/bi/ngt9bibosuarxvrnkv8vmnfwpmm.png" /></td>
<td><img src="https://habrastorage.org/webt/tm/jw/6l/tmjw6lff6czkwo_iyfol6ea3ruk.png" /></td>
</tr>
<tr><td><i>Цент здорового человека</i></td><td><i>Цент ленивца</i></td></tr>
</table>
Первый вариант способен успешно триангулироваться. Второй - обречён на провал, поскольку одной сеткой два пересекающихся объекта представить невозможно без решения задачи контурного объединения. Контурное объединение предполагает поиск точек пересечения двух контуров... Весьма затратная операция. Вместо этого, оба приведённых контура триангулируются по отдельности. Результат - одна сетка включающая подсетки для "/" и для "C". Такой сеточный символ будет отображаться хорошо только при выключенном тесте глубины. Это своего рода компромисс - библиотека готова к произволу, но жертвовать производительностью из-за "ленивого" дизайна не будет.
</p>
<h4>Выпуклая триангуляция</h4>
<p>
По предыдущим анимациям, думаю, становится ясен процесс подготовки сетки. На первом этапе делается выпуклая триангуляция без ограничений. То есть в триангуляции участвуют только точки. Кратко опишу алгоритм по следующей анимации.
<br><img src="https://habrastorage.org/webt/uz/ib/ti/uzibtidh0j7x7o9huunwscj7cbe.gif" /><br>
1) Перебираются точки триангуляции ранее отсортированные по координате (y). <i>Первая точка p19, потом p15 и так далее.</i>
2) Из каждой точки опускается вертикаль на заметающую ломаную. Эта вертикаль пересекает в составе ломаной определённый отрезок. <i>Заметающая ломаная, она же advancing front, изображена красным. На текущем шаге вертикаль вниз опускается из выделенной жирным точки. Находится отрезок под этой точкой.</i>
3) Найденный таким образом отрезок и текущая точка составляют новый треугольник,  после чего найденный отрезок исключается из заметающей ломаной, а заместо него вставляется 2 образовавшихся ребра треугольника. Если вертикаль опустилась точно по границе двух отрезков, то строится два треугольника.
4) Если после п.3 в составе ломаной образовалась остроугольная впадина из двух соседствующих отрезков, то на них строится новый треугольник. <i>Отдельно показано после обработки вершины p2</i>.
5) После перебора всех точек триангуляция достраивается до выпуклой. При этом строятся треугольники на всех соседствующих отрезках, образующих впадину. <i>Отдельно показано после обработки вершины p5</i>.
</p>
<p>
Данный алгоритм имеет близкое соответствие (в части Point event) тому, что был предложен в 2008 году авторами V. Domiter & B. Žalik в их публикации "Sweep‐line algorithm for constrained Delaunay triangulation" (DOI: 10.1080/13658810701492241). Замечательная особенность этого алгоритма заключается (помимо ассимптотической линейности в нашем применении) в том, что производится сетка уже достаточно приближенная к оптимальной. Хотя, конечно, такой она не является. После триангуляции требуется провести оптимизацию для соответствия критерию Делоне.
</p>
<p>
<u>По поводу вычислительной сложности</u>. На следующем рисунке приводится экспериментально полученный график, демонстрирующий линейную сложность вычислительного процесса.
<br><img src="https://habrastorage.org/webt/lb/o9/by/lbo9byxer_n3oxfnb3xdgu7sone.png" /><br>
Каждая точка на плоскости определяет зависимость процессорного времени от числа вершин при конвертировании одиночного глифа (по оси X - число входных вершин, по Y - время их обработки в микросекундах).
Видно, что точки хорошо приближаются прямой, что говорит о сложности всего вычислительного процесса (и процесса триангуляции в частности) близкой к O(N). Конечно, в алгоритме присутствует сортировка вершин со сложностью O(N log N) и ещё несколько нелинейных вычислений, но они требуют значительно меньше времени процессора, нежели чем алгоритм триангуляции. Поэтому на приведённом графике их вклад фактически не прослеживается.
</p>
<p>
На верхнем графике замечено, что среди всех глифов есть рекордсмен, контуры которого содержат в сумме более 2000 вершин. Представитель шрифта "Tibetan Machine Uni" с именем U+0FC7 (Tibetan Symbol Rdo Rje Rgya Gram) выигрывает всеобщее внимание:
<table>
<tr>
<td><img src="https://habrastorage.org/webt/zf/to/qh/zftoqhtdhqjjaeixcxn6mjm7tcs.png" /></td>
<td><img src="https://habrastorage.org/webt/oo/nb/1x/oonb1xsstkepba8xymwjgjyoavq.png" /></td>
</tr>
<tr>
<td><i>После триангуляции</i></td>
<td><i>Вывод OpenGL с MSAA</i></td>
</tr>
</table>Так и вижу рыдающего ребёнка на уроке каллиграфии...
</p>
<h3>Продолжение следует</h3>
<p>
По другим пунктам (добавление ограничений, удаление лишних треугольников, оптимизация Делоне и формирование сетки) продолжу позже.
</p>
<p>
Дальнейшее развитие ttf2mesh заключается в оптимизации, расширении поддержки на другие форматы шрифтов. Будет создана коллекция OBJ файлов разных шрифтов. Отдельно предстоит организовать текстовые слои с экспортом текста в сеточный формат, SVG и, возможно, в PostScript.
</p>
<p>
Разработка будет вестись по мере свободного времени в остатке. Если появятся варианты капитализировать работу или пойдут донаты - то быстрее, конечно.
</p>
<p>
Библиотека ttf2mesh доступна заинтересовавшимся <a href="https://github.com/fetisov/ttf2mesh">в репозитории</a> и имеет MIT-лицензию. Очень надеюсь, что она будет полезна общественности.
Ну и на последок - небольшая демонстрация работы:
<br><img src="https://habrastorage.org/webt/-z/60/mj/-z60mj6volo0p5unfcuu8fb1gtk.gif" /><br>
</p>
